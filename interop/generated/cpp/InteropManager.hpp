/*
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by codegen/generate.py from messages/interop_messages.h
 *
 * InteropManager - Extended Manager that provides location-transparent
 * actor lookups across C++ and Rust via FFI.
 *
 * Usage:
 *   class MyManager : public interop::InteropManager {
 *       MyManager() {
 *           auto* actor = new MyActor();
 *           manage(actor);
 *       }
 *   };
 *
 * Then actors can use get_actor_by_name() to get references to any actor,
 * whether it's a C++ actor or a Rust actor - completely transparently.
 */

#pragma once

#include "actors/act/Manager.hpp"
#include "actors/Actor.hpp"
#include "actors/ActorRef.hpp"
#include "InteropMessages.hpp"
#include "RustActorIF.hpp"
#include <string>
#include <unordered_map>
#include <memory>
#include <mutex>
#include <stdexcept>

// Forward declare the Rust bridge function
extern "C" {
    int32_t rust_actor_exists(const char* name);
}

namespace interop {

/**
 * RustActorProxy - A minimal Actor that forwards messages to Rust actors
 *
 * This provides location transparency: C++ actors get a pointer to this
 * proxy (just like any other Actor*), and call send() on it. The proxy
 * forwards messages to the Rust actor via FFI.
 */
class RustActorProxy : public actors::Actor {
    RustActorIF rust_actor_;

public:
    RustActorProxy(const std::string& rust_actor_name)
        : rust_actor_(rust_actor_name, "")
    {
        strncpy(name, rust_actor_name.c_str(), sizeof(name) - 1);
        name[sizeof(name) - 1] = '\0';
    }

    // Override send to forward to Rust
    void send(const actors::Message* m, actors::Actor* sender) noexcept override {
        // Forward to Rust based on message type
        if (m->get_message_id() == 1000) {
            rust_actor_.send(*static_cast<const msg::Ping*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1001) {
            rust_actor_.send(*static_cast<const msg::Pong*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1002) {
            rust_actor_.send(*static_cast<const msg::DataRequest*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1003) {
            rust_actor_.send(*static_cast<const msg::DataResponse*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1010) {
            rust_actor_.send(*static_cast<const msg::Subscribe*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1011) {
            rust_actor_.send(*static_cast<const msg::Unsubscribe*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1012) {
            rust_actor_.send(*static_cast<const msg::MarketUpdate*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1013) {
            rust_actor_.send(*static_cast<const msg::MarketDepth*>(m));
            delete m;
            return;
        }
        // Unknown message type, just delete it
        delete m;
    }
};

/**
 * InteropManager - Extended Manager with cross-language actor lookup
 *
 * Provides get_any_actor() that checks Rust registry in addition to
 * the C++ registry. Returns proxy actors for Rust actors.
 */
class InteropManager : public actors::Manager {
    // Cache of proxy actors for Rust actors
    mutable std::unordered_map<std::string, std::unique_ptr<RustActorProxy>> rust_proxies_;
    mutable std::mutex proxy_mutex_;

public:
    /**
     * Get any actor by name - checks C++ actors first, then Rust actors
     *
     * For Rust actors, returns a proxy that forwards via FFI.
     * Actors using this method don't know if they're talking to C++ or Rust.
     *
     * This is the preferred lookup method for interop scenarios.
     */
    actors::Actor* get_any_actor(const std::string& name) const {
        // Check C++ actors first (parent implementation)
        if (actors::Actor* actor = Manager::get_local_actor(name)) {
            return actor;
        }

        // Check Rust actors - return proxy if found
        if (rust_actor_exists(name.c_str())) {
            std::lock_guard<std::mutex> lock(proxy_mutex_);

            // Check cache first
            auto it = rust_proxies_.find(name);
            if (it != rust_proxies_.end()) {
                return it->second.get();
            }

            // Create new proxy
            auto proxy = std::make_unique<RustActorProxy>(name);
            auto* ptr = proxy.get();
            rust_proxies_[name] = std::move(proxy);
            return ptr;
        }

        return nullptr;
    }

    /**
     * Get an ActorRef for any actor by name
     *
     * Returns ActorRef that routes to local C++ actor or Rust actor via FFI.
     * This is the preferred method - actors use ActorRef, not Actor*.
     *
     * Usage:
     *   ActorRef pong = mgr->get_ref("rust_pong");
     *   pong.send(new msg::Ping{1}, this);  // Works for C++ or Rust!
     *
     * @throws std::runtime_error if actor not found
     */
    actors::ActorRef get_ref(const std::string& name) const {
        // Check C++ actors first
        if (actors::Actor* actor = Manager::get_local_actor(name)) {
            return actors::ActorRef(actor);
        }

        // Check Rust actors - return RustActorRef variant
        if (rust_actor_exists(name.c_str())) {
            return actors::ActorRef(actors::RustActorRef(name));
        }

        throw std::runtime_error("Actor not found: " + name);
    }
};

} // namespace interop
