/*
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by codegen/generate.py from messages/interop_messages.h
 *
 * InteropActorRef - Unified reference to local C++, Rust, or remote actors
 *
 * This extends the actors-cpp ActorRef concept to include cross-language
 * communication via FFI. It provides location transparency - actors don't
 * need to know whether the target is C++, Rust, or remote.
 */

#pragma once

#include <string>
#include <variant>
#include <stdexcept>
#include "actors/Actor.hpp"
#include "actors/Message.hpp"
#include "InteropMessages.hpp"
#include "RustActorIF.hpp"

namespace interop {

// Forward declare the existence check function
extern "C" int32_t rust_actor_exists(const char* name);

/**
 * RustActorRef - Reference to an actor in Rust
 *
 * Communicates via FFI bridge functions.
 */
class RustActorRef {
    std::string target_name_;
    std::string sender_name_;

public:
    RustActorRef(const std::string& target, const std::string& sender = "")
        : target_name_(target)
        , sender_name_(sender) {}

    /**
     * Send a message to the Rust actor
     *
     * Dispatches based on message ID to the appropriate typed send.
     * The message is deleted after sending (ownership transferred).
     */
    void send(const actors::Message* m, actors::Actor* sender = nullptr) const {
        // Update sender name if sender provided
        const char* sender_name_ptr = sender_name_.empty()
            ? (sender ? sender->get_name() : nullptr)
            : sender_name_.c_str();

        int msg_id = m->get_message_id();

        // Dispatch based on message ID
        // Generated dispatch code for each interop message type
        if (msg_id == 1000) {
            auto c_msg = static_cast<const msg::Ping*>(m)->to_c_struct();
            rust_actor_send(target_name_.c_str(), sender_name_ptr, 1000, &c_msg);
            delete m;
            return;
        }
        if (msg_id == 1001) {
            auto c_msg = static_cast<const msg::Pong*>(m)->to_c_struct();
            rust_actor_send(target_name_.c_str(), sender_name_ptr, 1001, &c_msg);
            delete m;
            return;
        }
        if (msg_id == 1002) {
            auto c_msg = static_cast<const msg::DataRequest*>(m)->to_c_struct();
            rust_actor_send(target_name_.c_str(), sender_name_ptr, 1002, &c_msg);
            delete m;
            return;
        }
        if (msg_id == 1003) {
            auto c_msg = static_cast<const msg::DataResponse*>(m)->to_c_struct();
            rust_actor_send(target_name_.c_str(), sender_name_ptr, 1003, &c_msg);
            delete m;
            return;
        }
        if (msg_id == 1010) {
            auto c_msg = static_cast<const msg::Subscribe*>(m)->to_c_struct();
            rust_actor_send(target_name_.c_str(), sender_name_ptr, 1010, &c_msg);
            delete m;
            return;
        }
        if (msg_id == 1011) {
            auto c_msg = static_cast<const msg::Unsubscribe*>(m)->to_c_struct();
            rust_actor_send(target_name_.c_str(), sender_name_ptr, 1011, &c_msg);
            delete m;
            return;
        }
        if (msg_id == 1012) {
            auto c_msg = static_cast<const msg::MarketUpdate*>(m)->to_c_struct();
            rust_actor_send(target_name_.c_str(), sender_name_ptr, 1012, &c_msg);
            delete m;
            return;
        }
        if (msg_id == 1013) {
            auto c_msg = static_cast<const msg::MarketDepth*>(m)->to_c_struct();
            rust_actor_send(target_name_.c_str(), sender_name_ptr, 1013, &c_msg);
            delete m;
            return;
        }

        // Unknown message type - can't send across FFI
        delete m;
        throw std::runtime_error("Unknown message type for FFI: " + std::to_string(msg_id));
    }

    /**
     * Send a message synchronously (blocks until processed)
     */
    void fast_send(const actors::Message* m, actors::Actor* sender = nullptr) const {
        const char* sender_name_ptr = sender_name_.empty()
            ? (sender ? sender->get_name() : nullptr)
            : sender_name_.c_str();

        int msg_id = m->get_message_id();

        // Dispatch based on message ID (fast_send version)
        if (msg_id == 1000) {
            auto c_msg = static_cast<const msg::Ping*>(m)->to_c_struct();
            rust_actor_fast_send(target_name_.c_str(), sender_name_ptr, 1000, &c_msg);
            return;
        }
        if (msg_id == 1001) {
            auto c_msg = static_cast<const msg::Pong*>(m)->to_c_struct();
            rust_actor_fast_send(target_name_.c_str(), sender_name_ptr, 1001, &c_msg);
            return;
        }
        if (msg_id == 1002) {
            auto c_msg = static_cast<const msg::DataRequest*>(m)->to_c_struct();
            rust_actor_fast_send(target_name_.c_str(), sender_name_ptr, 1002, &c_msg);
            return;
        }
        if (msg_id == 1003) {
            auto c_msg = static_cast<const msg::DataResponse*>(m)->to_c_struct();
            rust_actor_fast_send(target_name_.c_str(), sender_name_ptr, 1003, &c_msg);
            return;
        }
        if (msg_id == 1010) {
            auto c_msg = static_cast<const msg::Subscribe*>(m)->to_c_struct();
            rust_actor_fast_send(target_name_.c_str(), sender_name_ptr, 1010, &c_msg);
            return;
        }
        if (msg_id == 1011) {
            auto c_msg = static_cast<const msg::Unsubscribe*>(m)->to_c_struct();
            rust_actor_fast_send(target_name_.c_str(), sender_name_ptr, 1011, &c_msg);
            return;
        }
        if (msg_id == 1012) {
            auto c_msg = static_cast<const msg::MarketUpdate*>(m)->to_c_struct();
            rust_actor_fast_send(target_name_.c_str(), sender_name_ptr, 1012, &c_msg);
            return;
        }
        if (msg_id == 1013) {
            auto c_msg = static_cast<const msg::MarketDepth*>(m)->to_c_struct();
            rust_actor_fast_send(target_name_.c_str(), sender_name_ptr, 1013, &c_msg);
            return;
        }

        throw std::runtime_error("Unknown message type for FFI: " + std::to_string(msg_id));
    }

    const std::string& name() const { return target_name_; }
    bool exists() const { return rust_actor_exists(target_name_.c_str()) != 0; }
};

/**
 * LocalActorRef - Reference to an actor in the same process
 */
class LocalActorRef {
    actors::Actor* actor_;

public:
    explicit LocalActorRef(actors::Actor* a) : actor_(a) {}

    void send(const actors::Message* m, actors::Actor* sender = nullptr) {
        actor_->send(m, sender);
    }

    void fast_send(const actors::Message* m, actors::Actor* sender) {
        actor_->fast_send(m, sender);
    }

    const char* name() const { return actor_->get_name(); }
    actors::Actor* actor() const { return actor_; }
};

/**
 * ActorRef - Unified reference to local C++ or Rust actors
 *
 * Uses std::variant for zero-overhead polymorphism.
 * Same send() syntax for both C++ and Rust actors.
 *
 * Usage:
 *   ActorRef local_ref(cpp_actor);
 *   ActorRef rust_ref = ActorRef::rust("rust_pong", "cpp_ping");
 *
 *   local_ref.send(new Ping{1}, this);  // local C++
 *   rust_ref.send(new Ping{1}, this);   // Rust via FFI - same syntax!
 */
class ActorRef {
    std::variant<LocalActorRef, RustActorRef> ref_;

public:
    // Construct from local C++ actor
    explicit ActorRef(actors::Actor* a) : ref_(LocalActorRef(a)) {}

    // Construct from RustActorRef
    explicit ActorRef(RustActorRef rust_ref) : ref_(std::move(rust_ref)) {}

    // Construct Rust actor reference (factory method)
    static ActorRef rust(const std::string& name, const std::string& sender = "") {
        return ActorRef(RustActorRef(name, sender));
    }

    // Copy/move constructors
    ActorRef(const ActorRef&) = default;
    ActorRef(ActorRef&&) = default;
    ActorRef& operator=(const ActorRef&) = default;
    ActorRef& operator=(ActorRef&&) = default;

    /**
     * Send a message asynchronously
     * Works identically for C++ and Rust actors
     */
    void send(const actors::Message* m, actors::Actor* sender = nullptr) {
        std::visit([&](auto& r) { r.send(m, sender); }, ref_);
    }

    /**
     * Send a message synchronously
     */
    void fast_send(const actors::Message* m, actors::Actor* sender = nullptr) {
        std::visit([&](auto& r) { r.fast_send(m, sender); }, ref_);
    }

    bool is_local() const { return std::holds_alternative<LocalActorRef>(ref_); }
    bool is_rust() const { return std::holds_alternative<RustActorRef>(ref_); }

    // Get name
    std::string name() const {
        return std::visit([](const auto& r) -> std::string {
            if constexpr (std::is_same_v<std::decay_t<decltype(r)>, LocalActorRef>) {
                return r.name();
            } else {
                return r.name();
            }
        }, ref_);
    }

    // Access underlying local actor (throws if Rust)
    actors::Actor* actor() const {
        if (auto* local = std::get_if<LocalActorRef>(&ref_)) {
            return local->actor();
        }
        throw std::runtime_error("Cannot get actor pointer for Rust actor");
    }

};

} // namespace interop
