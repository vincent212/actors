/*
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by codegen/generate.py from messages/interop_messages.h
 *
 * Uses Manager's actor registry instead of a separate registry.
 */

#include "CppActorBridge.hpp"
#include "InteropMessages.hpp"
#include "RustActorIF.hpp"
#include "actors/Actor.hpp"
#include "actors/act/Manager.hpp"

#include <string>
#include <mutex>
#include <memory>
#include <unordered_map>

namespace {

// Global Manager pointer - set by cpp_actor_init()
actors::Manager* g_manager = nullptr;

/**
 * RustSenderProxy - A minimal Actor that forwards reply() calls back to Rust
 *
 * When a Rust actor sends a message to C++, we create one of these as the
 * "sender" so that the C++ actor can call reply() naturally. The proxy
 * intercepts the reply message and forwards it back to the Rust actor via FFI.
 */
class RustSenderProxy : public actors::Actor {
    interop::RustActorIF rust_actor_;

public:
    RustSenderProxy(const std::string& rust_actor_name, const std::string& cpp_actor_name)
        : rust_actor_(rust_actor_name, cpp_actor_name)
    {
        strncpy(name, rust_actor_name.c_str(), sizeof(name) - 1);
        name[sizeof(name) - 1] = '\0';
    }

    // Override send to forward to Rust
    void send(const actors::Message* m, actors::Actor* sender) noexcept override {
        // Forward to Rust based on message type
        if (m->get_message_id() == 1000) {
            rust_actor_.send(*static_cast<const msg::Ping*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1001) {
            rust_actor_.send(*static_cast<const msg::Pong*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1002) {
            rust_actor_.send(*static_cast<const msg::DataRequest*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1003) {
            rust_actor_.send(*static_cast<const msg::DataResponse*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1010) {
            rust_actor_.send(*static_cast<const msg::Subscribe*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1011) {
            rust_actor_.send(*static_cast<const msg::Unsubscribe*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1012) {
            rust_actor_.send(*static_cast<const msg::MarketUpdate*>(m));
            delete m;
            return;
        }
        if (m->get_message_id() == 1013) {
            rust_actor_.send(*static_cast<const msg::MarketDepth*>(m));
            delete m;
            return;
        }
        // Unknown message type, just delete it
        delete m;
    }
};

// Cache of proxy actors (reused across multiple messages from same sender)
std::unordered_map<std::string, std::unique_ptr<RustSenderProxy>> proxy_cache;
std::mutex proxy_mutex;

/**
 * Get or create a proxy actor for a Rust sender.
 * The proxy enables C++ actors to use reply() naturally.
 */
actors::Actor* get_sender_proxy(const char* sender_name, const char* receiver_name) {
    if (!sender_name || sender_name[0] == '\0') {
        return nullptr;
    }

    std::string key = std::string(sender_name) + "->" + (receiver_name ? receiver_name : "");

    std::lock_guard<std::mutex> lock(proxy_mutex);
    auto it = proxy_cache.find(key);
    if (it != proxy_cache.end()) {
        return it->second.get();
    }

    // Create new proxy
    auto proxy = std::make_unique<RustSenderProxy>(sender_name, receiver_name ? receiver_name : "");
    auto* ptr = proxy.get();
    proxy_cache[key] = std::move(proxy);
    return ptr;
}

} // anonymous namespace

extern "C" {

void cpp_actor_init(actors::Manager* mgr) {
    g_manager = mgr;
}

void cpp_actor_shutdown() {
    std::lock_guard<std::mutex> lock(proxy_mutex);
    proxy_cache.clear();
    g_manager = nullptr;
}

int32_t cpp_actor_exists(const char* name) {
    if (!name || !g_manager) return 0;
    return g_manager->get_actor_by_name(name) != nullptr ? 1 : 0;
}

int32_t cpp_actor_send(
    const char* actor_name,
    const char* sender_name,
    int32_t msg_type,
    const void* msg_data
) {
    if (!actor_name || !msg_data || !g_manager) return -1;

    actors::Actor* actor = g_manager->get_actor_by_name(actor_name);
    if (!actor) return -1;  // Actor not found

    actors::Actor* sender = get_sender_proxy(sender_name, actor_name);

    // Dispatch based on message type
    switch (msg_type) {
        case 1000: {
            auto* cpp_msg = new msg::Ping(
                msg::Ping::from_c_struct(
                    *static_cast<const ::Ping*>(msg_data)
                )
            );
            actor->send(cpp_msg, sender);
            break;
        }
        case 1001: {
            auto* cpp_msg = new msg::Pong(
                msg::Pong::from_c_struct(
                    *static_cast<const ::Pong*>(msg_data)
                )
            );
            actor->send(cpp_msg, sender);
            break;
        }
        case 1002: {
            auto* cpp_msg = new msg::DataRequest(
                msg::DataRequest::from_c_struct(
                    *static_cast<const ::DataRequest*>(msg_data)
                )
            );
            actor->send(cpp_msg, sender);
            break;
        }
        case 1003: {
            auto* cpp_msg = new msg::DataResponse(
                msg::DataResponse::from_c_struct(
                    *static_cast<const ::DataResponse*>(msg_data)
                )
            );
            actor->send(cpp_msg, sender);
            break;
        }
        case 1010: {
            auto* cpp_msg = new msg::Subscribe(
                msg::Subscribe::from_c_struct(
                    *static_cast<const ::Subscribe*>(msg_data)
                )
            );
            actor->send(cpp_msg, sender);
            break;
        }
        case 1011: {
            auto* cpp_msg = new msg::Unsubscribe(
                msg::Unsubscribe::from_c_struct(
                    *static_cast<const ::Unsubscribe*>(msg_data)
                )
            );
            actor->send(cpp_msg, sender);
            break;
        }
        case 1012: {
            auto* cpp_msg = new msg::MarketUpdate(
                msg::MarketUpdate::from_c_struct(
                    *static_cast<const ::MarketUpdate*>(msg_data)
                )
            );
            actor->send(cpp_msg, sender);
            break;
        }
        case 1013: {
            auto* cpp_msg = new msg::MarketDepth(
                msg::MarketDepth::from_c_struct(
                    *static_cast<const ::MarketDepth*>(msg_data)
                )
            );
            actor->send(cpp_msg, sender);
            break;
        }
        default:
            return -2; // Unknown message type
    }

    return 0;
}

int32_t cpp_actor_fast_send(
    const char* actor_name,
    const char* sender_name,
    int32_t msg_type,
    const void* msg_data
) {
    if (!actor_name || !msg_data || !g_manager) return -1;

    actors::Actor* actor = g_manager->get_actor_by_name(actor_name);
    if (!actor) return -1;  // Actor not found

    actors::Actor* sender = get_sender_proxy(sender_name, actor_name);

    // Dispatch based on message type (sync version)
    switch (msg_type) {
        case 1000: {
            msg::Ping cpp_msg = msg::Ping::from_c_struct(
                *static_cast<const ::Ping*>(msg_data)
            );
            actor->fast_send(&cpp_msg, sender);
            break;
        }
        case 1001: {
            msg::Pong cpp_msg = msg::Pong::from_c_struct(
                *static_cast<const ::Pong*>(msg_data)
            );
            actor->fast_send(&cpp_msg, sender);
            break;
        }
        case 1002: {
            msg::DataRequest cpp_msg = msg::DataRequest::from_c_struct(
                *static_cast<const ::DataRequest*>(msg_data)
            );
            actor->fast_send(&cpp_msg, sender);
            break;
        }
        case 1003: {
            msg::DataResponse cpp_msg = msg::DataResponse::from_c_struct(
                *static_cast<const ::DataResponse*>(msg_data)
            );
            actor->fast_send(&cpp_msg, sender);
            break;
        }
        case 1010: {
            msg::Subscribe cpp_msg = msg::Subscribe::from_c_struct(
                *static_cast<const ::Subscribe*>(msg_data)
            );
            actor->fast_send(&cpp_msg, sender);
            break;
        }
        case 1011: {
            msg::Unsubscribe cpp_msg = msg::Unsubscribe::from_c_struct(
                *static_cast<const ::Unsubscribe*>(msg_data)
            );
            actor->fast_send(&cpp_msg, sender);
            break;
        }
        case 1012: {
            msg::MarketUpdate cpp_msg = msg::MarketUpdate::from_c_struct(
                *static_cast<const ::MarketUpdate*>(msg_data)
            );
            actor->fast_send(&cpp_msg, sender);
            break;
        }
        case 1013: {
            msg::MarketDepth cpp_msg = msg::MarketDepth::from_c_struct(
                *static_cast<const ::MarketDepth*>(msg_data)
            );
            actor->fast_send(&cpp_msg, sender);
            break;
        }
        default:
            return -2; // Unknown message type
    }

    return 0;
}

} // extern "C"
