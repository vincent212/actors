/*
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by codegen/generate.py from messages/interop_messages.h
 *
 * RustActorIF - C++ interface to send messages to Rust actors
 */

#pragma once

#include <string>
#include <cstring>
#include "InteropMessages.hpp"

// Forward declare the Rust bridge functions
extern "C" {
    int32_t rust_actor_send(
        const char* actor_name,
        const char* sender_name,
        int32_t msg_type,
        const void* msg_data
    );

    int32_t rust_actor_fast_send(
        const char* actor_name,
        const char* sender_name,
        int32_t msg_type,
        const void* msg_data
    );

    int32_t rust_actor_exists(const char* name);
}

namespace interop {

/**
 * RustActorIF - Interface for C++ actors to send messages to Rust actors
 *
 * Usage:
 *   RustActorIF rust_actor("my_rust_actor", "my_cpp_actor");
 *   rust_actor.send(msg::Ping{42});           // async
 *   rust_actor.fast_send(msg::Ping{42});      // sync (blocks until processed)
 */
class RustActorIF {
public:
    RustActorIF(const std::string& actor_name, const std::string& sender_name = "")
        : actor_name_(actor_name)
        , sender_name_(sender_name) {}

    /**
     * Send a message asynchronously (fire-and-forget)
     * Returns 0 on success, -1 if actor not found
     */
    template<typename Msg>
    int send(const Msg& msg) const {
        auto c_msg = msg.to_c_struct();
        return rust_actor_send(
            actor_name_.c_str(),
            sender_name_.empty() ? nullptr : sender_name_.c_str(),
            Msg::ID,
            &c_msg
        );
    }

    /**
     * Send a message synchronously (blocks until message is processed)
     * Returns 0 on success, -1 if actor not found
     */
    template<typename Msg>
    int fast_send(const Msg& msg) const {
        auto c_msg = msg.to_c_struct();
        return rust_actor_fast_send(
            actor_name_.c_str(),
            sender_name_.empty() ? nullptr : sender_name_.c_str(),
            Msg::ID,
            &c_msg
        );
    }

    bool exists() const {
        return rust_actor_exists(actor_name_.c_str()) != 0;
    }

    const std::string& name() const { return actor_name_; }

private:
    std::string actor_name_;
    std::string sender_name_;
};

} // namespace interop
