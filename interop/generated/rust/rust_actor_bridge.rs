//! AUTO-GENERATED FILE - DO NOT EDIT
//! Generated by codegen/generate.py from messages/interop_messages.h
//!
//! Rust Actor Bridge - extern "C" functions callable from C++
//!
//! Uses Rust Manager's actor registry instead of a separate registry.

#![allow(dead_code)]

use std::ffi::CStr;
use std::os::raw::{c_char, c_int, c_void};
use std::sync::Mutex;

use actors::{ActorRef, Manager};
use crate::interop_messages::*;

// Wrapper to make Manager pointer safe for static storage
struct ManagerPtr(*const Manager);
unsafe impl Send for ManagerPtr {}
unsafe impl Sync for ManagerPtr {}

// Global Manager pointer - set by rust_actor_init()
// We use Mutex with a wrapper type since raw pointers don't impl Send/Sync
static MANAGER: Mutex<ManagerPtr> = Mutex::new(ManagerPtr(std::ptr::null()));

/// Get reference to the global Manager
fn get_manager() -> Option<&'static Manager> {
    let guard = MANAGER.lock().ok()?;
    if guard.0.is_null() {
        return None;
    }
    // SAFETY: Manager is guaranteed to outlive the FFI calls
    Some(unsafe { &*guard.0 })
}

/// Create a CppActorRef for reply routing (wraps CppActorIF)
fn create_cpp_sender_ref(sender_name: &str, receiver_name: &str) -> Option<ActorRef> {
    // For now, we don't have a direct way to create a Rust ActorRef for C++ actors
    // The receiver will use CppActorIF directly for replies
    None
}

/// Initialize the Rust actor bridge with a Manager pointer
/// The Manager's registry is used to look up actors by name
#[no_mangle]
pub extern "C" fn rust_actor_init(mgr: *const Manager) {
    if let Ok(mut guard) = MANAGER.lock() {
        guard.0 = mgr;
    }
}

/// Shutdown the Rust actor runtime
#[no_mangle]
pub extern "C" fn rust_actor_shutdown() {
    if let Ok(mut guard) = MANAGER.lock() {
        guard.0 = std::ptr::null();
    }
}

/// Check if a Rust actor exists (looks up in Manager's registry)
#[no_mangle]
pub extern "C" fn rust_actor_exists(name: *const c_char) -> c_int {
    if name.is_null() {
        return 0;
    }
    let name_str = match unsafe { CStr::from_ptr(name).to_str() } {
        Ok(s) => s,
        Err(_) => return 0,
    };
    let mgr = match get_manager() {
        Some(m) => m,
        None => return 0,
    };
    if mgr.get_ref(name_str).is_some() { 1 } else { 0 }
}

/// Send a message to a Rust actor (async - called from C++)
/// sender_name is used to create a sender ActorRef for replies
/// Returns 0 on success, -1 if actor not found, -2 if unknown message type
#[no_mangle]
pub extern "C" fn rust_actor_send(
    actor_name: *const c_char,
    sender_name: *const c_char,
    msg_type: c_int,
    msg_data: *const c_void,
) -> c_int {
    if actor_name.is_null() || msg_data.is_null() {
        return -1;
    }

    let name = match unsafe { CStr::from_ptr(actor_name).to_str() } {
        Ok(s) => s,
        Err(_) => return -1,
    };

    let mgr = match get_manager() {
        Some(m) => m,
        None => return -1,
    };

    let actor_ref = match mgr.get_ref(name) {
        Some(r) => r,
        None => return -1,  // Actor not found
    };

    // Create sender ref for replies (if sender name provided)
    let sender_ref: Option<ActorRef> = if sender_name.is_null() {
        None
    } else {
        // For C++ senders, we create a special ActorRef that routes back via FFI
        // This is handled by the CppSenderProxy in the actor
        None // TODO: Implement CppActorRef
    };

    // Convert C struct to Rust message and send
    match msg_type {
        1000 => {
            let c_msg = unsafe { &*(msg_data as *const CPing) };
            let rust_msg = Ping::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }
        1001 => {
            let c_msg = unsafe { &*(msg_data as *const CPong) };
            let rust_msg = Pong::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }
        1002 => {
            let c_msg = unsafe { &*(msg_data as *const CDataRequest) };
            let rust_msg = DataRequest::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }
        1003 => {
            let c_msg = unsafe { &*(msg_data as *const CDataResponse) };
            let rust_msg = DataResponse::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }
        1010 => {
            let c_msg = unsafe { &*(msg_data as *const CSubscribe) };
            let rust_msg = Subscribe::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }
        1011 => {
            let c_msg = unsafe { &*(msg_data as *const CUnsubscribe) };
            let rust_msg = Unsubscribe::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }
        1012 => {
            let c_msg = unsafe { &*(msg_data as *const CMarketUpdate) };
            let rust_msg = MarketUpdate::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }
        1013 => {
            let c_msg = unsafe { &*(msg_data as *const CMarketDepth) };
            let rust_msg = MarketDepth::from_c_struct(c_msg);
            actor_ref.send(Box::new(rust_msg), sender_ref);
        }
        _ => return -2,  // Unknown message type
    }

    0  // Success
}
