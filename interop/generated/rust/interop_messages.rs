//! AUTO-GENERATED FILE - DO NOT EDIT
//! Generated by codegen/generate.py from messages/interop_messages.h

#![allow(dead_code)]

pub const INTEROP_STRING_MAX: usize = 64;

/// Fixed-size string for FFI (matches C interop_string)
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CInteropString {
    pub data: [u8; INTEROP_STRING_MAX],
    pub len: u32,
}

impl Default for CInteropString {
    fn default() -> Self {
        CInteropString {
            data: [0u8; INTEROP_STRING_MAX],
            len: 0,
        }
    }
}

impl CInteropString {
    pub fn from_str(s: &str) -> Self {
        let mut result = Self::default();
        let bytes = s.as_bytes();
        let copy_len = bytes.len().min(INTEROP_STRING_MAX - 1);
        result.data[..copy_len].copy_from_slice(&bytes[..copy_len]);
        result.len = copy_len as u32;
        result
    }

    pub fn to_string(&self) -> String {
        let len = self.len as usize;
        String::from_utf8_lossy(&self.data[..len]).to_string()
    }
}

// Message ID constants
pub const MSG_PING: i32 = 1000;
pub const MSG_PONG: i32 = 1001;
pub const MSG_DATAREQUEST: i32 = 1002;
pub const MSG_DATARESPONSE: i32 = 1003;
pub const MSG_SUBSCRIBE: i32 = 1010;
pub const MSG_UNSUBSCRIBE: i32 = 1011;
pub const MSG_MARKETUPDATE: i32 = 1012;
pub const MSG_MARKETDEPTH: i32 = 1013;

/// C-compatible Ping struct for FFI
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CPing {
    pub count: i32,
}

impl Default for CPing {
    fn default() -> Self {
        CPing {
            count: 0,
        }
    }
}

/// Rust-native Ping message
#[derive(Clone, Debug)]
pub struct Ping {
    pub count: i32,
}

impl Ping {
    pub const ID: i32 = 1000;

    pub fn to_c_struct(&self) -> CPing {
        CPing {
            count: self.count,
        }
    }

    pub fn from_c_struct(c: &CPing) -> Self {
        Ping {
            count: c.count,
        }
    }
}

/// Implement Message trait for actor messaging
impl actors::Message for Ping {
    fn as_any(&self) -> &dyn std::any::Any { self }
    fn as_any_mut(&mut self) -> &mut dyn std::any::Any { self }
    fn message_id(&self) -> i32 { 1000 }
}

/// C-compatible Pong struct for FFI
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CPong {
    pub count: i32,
}

impl Default for CPong {
    fn default() -> Self {
        CPong {
            count: 0,
        }
    }
}

/// Rust-native Pong message
#[derive(Clone, Debug)]
pub struct Pong {
    pub count: i32,
}

impl Pong {
    pub const ID: i32 = 1001;

    pub fn to_c_struct(&self) -> CPong {
        CPong {
            count: self.count,
        }
    }

    pub fn from_c_struct(c: &CPong) -> Self {
        Pong {
            count: c.count,
        }
    }
}

/// Implement Message trait for actor messaging
impl actors::Message for Pong {
    fn as_any(&self) -> &dyn std::any::Any { self }
    fn as_any_mut(&mut self) -> &mut dyn std::any::Any { self }
    fn message_id(&self) -> i32 { 1001 }
}

/// C-compatible DataRequest struct for FFI
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CDataRequest {
    pub request_id: i32,
    pub symbol: CInteropString,
}

impl Default for CDataRequest {
    fn default() -> Self {
        CDataRequest {
            request_id: 0,
            symbol: CInteropString::default(),
        }
    }
}

/// Rust-native DataRequest message
#[derive(Clone, Debug)]
pub struct DataRequest {
    pub request_id: i32,
    pub symbol: String,
}

impl DataRequest {
    pub const ID: i32 = 1002;

    pub fn to_c_struct(&self) -> CDataRequest {
        CDataRequest {
            request_id: self.request_id,
            symbol: CInteropString::from_str(&self.symbol),
        }
    }

    pub fn from_c_struct(c: &CDataRequest) -> Self {
        DataRequest {
            request_id: c.request_id,
            symbol: c.symbol.to_string(),
        }
    }
}

/// Implement Message trait for actor messaging
impl actors::Message for DataRequest {
    fn as_any(&self) -> &dyn std::any::Any { self }
    fn as_any_mut(&mut self) -> &mut dyn std::any::Any { self }
    fn message_id(&self) -> i32 { 1002 }
}

/// C-compatible DataResponse struct for FFI
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CDataResponse {
    pub request_id: i32,
    pub value: f64,
    pub found: i32,
}

impl Default for CDataResponse {
    fn default() -> Self {
        CDataResponse {
            request_id: 0,
            value: 0.0,
            found: 0,
        }
    }
}

/// Rust-native DataResponse message
#[derive(Clone, Debug)]
pub struct DataResponse {
    pub request_id: i32,
    pub value: f64,
    pub found: bool,
}

impl DataResponse {
    pub const ID: i32 = 1003;

    pub fn to_c_struct(&self) -> CDataResponse {
        CDataResponse {
            request_id: self.request_id,
            value: self.value,
            found: if self.found { 1 } else { 0 },
        }
    }

    pub fn from_c_struct(c: &CDataResponse) -> Self {
        DataResponse {
            request_id: c.request_id,
            value: c.value,
            found: c.found != 0,
        }
    }
}

/// Implement Message trait for actor messaging
impl actors::Message for DataResponse {
    fn as_any(&self) -> &dyn std::any::Any { self }
    fn as_any_mut(&mut self) -> &mut dyn std::any::Any { self }
    fn message_id(&self) -> i32 { 1003 }
}

/// C-compatible Subscribe struct for FFI
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CSubscribe {
    pub topic: [u8; 32],
}

impl Default for CSubscribe {
    fn default() -> Self {
        CSubscribe {
            topic: [0; 32],
        }
    }
}

/// Rust-native Subscribe message
#[derive(Clone, Debug)]
pub struct Subscribe {
    pub topic: [u8; 32],
}

impl Subscribe {
    pub const ID: i32 = 1010;

    pub fn to_c_struct(&self) -> CSubscribe {
        CSubscribe {
            topic: self.topic,
        }
    }

    pub fn from_c_struct(c: &CSubscribe) -> Self {
        Subscribe {
            topic: c.topic,
        }
    }
}

/// Implement Message trait for actor messaging
impl actors::Message for Subscribe {
    fn as_any(&self) -> &dyn std::any::Any { self }
    fn as_any_mut(&mut self) -> &mut dyn std::any::Any { self }
    fn message_id(&self) -> i32 { 1010 }
}

/// C-compatible Unsubscribe struct for FFI
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CUnsubscribe {
    pub topic: [u8; 32],
}

impl Default for CUnsubscribe {
    fn default() -> Self {
        CUnsubscribe {
            topic: [0; 32],
        }
    }
}

/// Rust-native Unsubscribe message
#[derive(Clone, Debug)]
pub struct Unsubscribe {
    pub topic: [u8; 32],
}

impl Unsubscribe {
    pub const ID: i32 = 1011;

    pub fn to_c_struct(&self) -> CUnsubscribe {
        CUnsubscribe {
            topic: self.topic,
        }
    }

    pub fn from_c_struct(c: &CUnsubscribe) -> Self {
        Unsubscribe {
            topic: c.topic,
        }
    }
}

/// Implement Message trait for actor messaging
impl actors::Message for Unsubscribe {
    fn as_any(&self) -> &dyn std::any::Any { self }
    fn as_any_mut(&mut self) -> &mut dyn std::any::Any { self }
    fn message_id(&self) -> i32 { 1011 }
}

/// C-compatible MarketUpdate struct for FFI
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CMarketUpdate {
    pub symbol: [u8; 8],
    pub price: f64,
    pub timestamp: i64,
    pub volume: i32,
}

impl Default for CMarketUpdate {
    fn default() -> Self {
        CMarketUpdate {
            symbol: [0; 8],
            price: 0.0,
            timestamp: 0,
            volume: 0,
        }
    }
}

/// Rust-native MarketUpdate message
#[derive(Clone, Debug)]
pub struct MarketUpdate {
    pub symbol: [u8; 8],
    pub price: f64,
    pub timestamp: i64,
    pub volume: i32,
}

impl MarketUpdate {
    pub const ID: i32 = 1012;

    pub fn to_c_struct(&self) -> CMarketUpdate {
        CMarketUpdate {
            symbol: self.symbol,
            price: self.price,
            timestamp: self.timestamp,
            volume: self.volume,
        }
    }

    pub fn from_c_struct(c: &CMarketUpdate) -> Self {
        MarketUpdate {
            symbol: c.symbol,
            price: c.price,
            timestamp: c.timestamp,
            volume: c.volume,
        }
    }
}

/// Implement Message trait for actor messaging
impl actors::Message for MarketUpdate {
    fn as_any(&self) -> &dyn std::any::Any { self }
    fn as_any_mut(&mut self) -> &mut dyn std::any::Any { self }
    fn message_id(&self) -> i32 { 1012 }
}

/// C-compatible MarketDepth struct for FFI
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CMarketDepth {
    pub symbol: [u8; 8],
    pub num_levels: i32,
    pub bid_prices: [f64; 5],
    pub ask_prices: [f64; 5],
    pub bid_sizes: [i32; 5],
    pub ask_sizes: [i32; 5],
}

impl Default for CMarketDepth {
    fn default() -> Self {
        CMarketDepth {
            symbol: [0; 8],
            num_levels: 0,
            bid_prices: [0.0; 5],
            ask_prices: [0.0; 5],
            bid_sizes: [0; 5],
            ask_sizes: [0; 5],
        }
    }
}

/// Rust-native MarketDepth message
#[derive(Clone, Debug)]
pub struct MarketDepth {
    pub symbol: [u8; 8],
    pub num_levels: i32,
    pub bid_prices: [f64; 5],
    pub ask_prices: [f64; 5],
    pub bid_sizes: [i32; 5],
    pub ask_sizes: [i32; 5],
}

impl MarketDepth {
    pub const ID: i32 = 1013;

    pub fn to_c_struct(&self) -> CMarketDepth {
        CMarketDepth {
            symbol: self.symbol,
            num_levels: self.num_levels,
            bid_prices: self.bid_prices,
            ask_prices: self.ask_prices,
            bid_sizes: self.bid_sizes,
            ask_sizes: self.ask_sizes,
        }
    }

    pub fn from_c_struct(c: &CMarketDepth) -> Self {
        MarketDepth {
            symbol: c.symbol,
            num_levels: c.num_levels,
            bid_prices: c.bid_prices,
            ask_prices: c.ask_prices,
            bid_sizes: c.bid_sizes,
            ask_sizes: c.ask_sizes,
        }
    }
}

/// Implement Message trait for actor messaging
impl actors::Message for MarketDepth {
    fn as_any(&self) -> &dyn std::any::Any { self }
    fn as_any_mut(&mut self) -> &mut dyn std::any::Any { self }
    fn message_id(&self) -> i32 { 1013 }
}

