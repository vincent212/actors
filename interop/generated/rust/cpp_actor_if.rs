//! AUTO-GENERATED FILE - DO NOT EDIT
//! Generated by codegen/generate.py from messages/interop_messages.h
//!
//! CppActorIF - Rust interface to send messages to C++ actors

#![allow(dead_code)]

use std::ffi::CString;
use std::os::raw::{c_char, c_int, c_void};

use crate::interop_messages::*;

// C++ bridge functions - resolved at final link time (no #[link] attribute)
// The final executable must link both Rust and C++ code together
extern "C" {
    fn cpp_actor_send(
        actor_name: *const c_char,
        sender_name: *const c_char,
        msg_type: c_int,
        msg_data: *const c_void,
    ) -> c_int;

    fn cpp_actor_exists(name: *const c_char) -> c_int;
}

/// Trait for messages that can be sent via FFI
pub trait InteropMessage {
    type CStruct;
    const MSG_ID: i32;
    fn to_c_struct(&self) -> Self::CStruct;
}

impl InteropMessage for Ping {
    type CStruct = CPing;
    const MSG_ID: i32 = 1000;
    fn to_c_struct(&self) -> Self::CStruct {
        Ping::to_c_struct(self)
    }
}

impl InteropMessage for Pong {
    type CStruct = CPong;
    const MSG_ID: i32 = 1001;
    fn to_c_struct(&self) -> Self::CStruct {
        Pong::to_c_struct(self)
    }
}

impl InteropMessage for DataRequest {
    type CStruct = CDataRequest;
    const MSG_ID: i32 = 1002;
    fn to_c_struct(&self) -> Self::CStruct {
        DataRequest::to_c_struct(self)
    }
}

impl InteropMessage for DataResponse {
    type CStruct = CDataResponse;
    const MSG_ID: i32 = 1003;
    fn to_c_struct(&self) -> Self::CStruct {
        DataResponse::to_c_struct(self)
    }
}

impl InteropMessage for Subscribe {
    type CStruct = CSubscribe;
    const MSG_ID: i32 = 1010;
    fn to_c_struct(&self) -> Self::CStruct {
        Subscribe::to_c_struct(self)
    }
}

impl InteropMessage for Unsubscribe {
    type CStruct = CUnsubscribe;
    const MSG_ID: i32 = 1011;
    fn to_c_struct(&self) -> Self::CStruct {
        Unsubscribe::to_c_struct(self)
    }
}

impl InteropMessage for MarketUpdate {
    type CStruct = CMarketUpdate;
    const MSG_ID: i32 = 1012;
    fn to_c_struct(&self) -> Self::CStruct {
        MarketUpdate::to_c_struct(self)
    }
}

impl InteropMessage for MarketDepth {
    type CStruct = CMarketDepth;
    const MSG_ID: i32 = 1013;
    fn to_c_struct(&self) -> Self::CStruct {
        MarketDepth::to_c_struct(self)
    }
}

/// CppActorIF - Interface for Rust actors to send messages to C++ actors
///
/// Usage:
///   let cpp_actor = CppActorIF::new("my_cpp_actor", "my_rust_actor");
///   cpp_actor.send(&Ping { count: 42 });           // async (fire-and-forget)
pub struct CppActorIF {
    actor_name: CString,
    sender_name: Option<CString>,
}

impl CppActorIF {
    pub fn new(actor_name: &str, sender_name: Option<&str>) -> Self {
        CppActorIF {
            actor_name: CString::new(actor_name).unwrap(),
            sender_name: sender_name.map(|s| CString::new(s).unwrap()),
        }
    }

    /// Send a message asynchronously (fire-and-forget)
    /// Returns 0 on success, -1 if actor not found
    pub fn send<M: InteropMessage>(&self, msg: &M) -> i32 {
        let c_msg = msg.to_c_struct();
        let sender_ptr = self.sender_name
            .as_ref()
            .map(|s| s.as_ptr())
            .unwrap_or(std::ptr::null());
        unsafe {
            cpp_actor_send(
                self.actor_name.as_ptr(),
                sender_ptr,
                M::MSG_ID,
                &c_msg as *const _ as *const c_void,
            )
        }
    }

    pub fn exists(&self) -> bool {
        unsafe { cpp_actor_exists(self.actor_name.as_ptr()) != 0 }
    }

    pub fn name(&self) -> &str {
        self.actor_name.to_str().unwrap()
    }
}
